// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Wages.proto

#import "GPBProtocolBuffers_RuntimeSupport.h"
#import "Wages.pbobjc.h"
#import "BasketballDataCenter.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma mark - WagesRoot

@implementation WagesRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    registry = [[GPBExtensionRegistry alloc] init];
    static GPBExtensionDescription descriptions[] = {
    };
    #pragma unused (descriptions)
    [registry addExtensions:[PBMBasketballDataCenterRoot extensionRegistry]];
  }
  return registry;
}

@end

static GPBFileDescriptor *WagesRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"Dacai.Protobuf"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - WagesHome

@implementation WagesHome

@dynamic hasFansCount, fansCount;
@dynamic hasProfit, profit;
@dynamic wagesItemsArray;
@dynamic hasBackgroudImg, backgroudImg;
@dynamic hasWagesCount, wagesCount;

typedef struct WagesHome_Storage {
  uint32_t _has_storage_[1];
  int32_t fansCount;
  NSString *profit;
  NSMutableArray *wagesItemsArray;
  NSString *backgroudImg;
  int64_t wagesCount;
} WagesHome_Storage;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fansCount",
        .number = WagesHome_FieldNumber_FansCount,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .type = GPBTypeInt32,
        .offset = offsetof(WagesHome_Storage, fansCount),
        .defaultValue.valueInt32 = 0,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "profit",
        .number = WagesHome_FieldNumber_Profit,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(WagesHome_Storage, profit),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "wagesItemsArray",
        .number = WagesHome_FieldNumber_WagesItemsArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .type = GPBTypeMessage,
        .offset = offsetof(WagesHome_Storage, wagesItemsArray),
        .defaultValue.valueMessage = nil,
        .typeSpecific.className = GPBStringifySymbol(Wages),
        .fieldOptions = NULL,
      },
      {
        .name = "backgroudImg",
        .number = WagesHome_FieldNumber_BackgroudImg,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(WagesHome_Storage, backgroudImg),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "wagesCount",
        .number = WagesHome_FieldNumber_WagesCount,
        .hasIndex = 4,
        .flags = GPBFieldOptional,
        .type = GPBTypeInt64,
        .offset = offsetof(WagesHome_Storage, wagesCount),
        .defaultValue.valueInt64 = 0LL,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    descriptor = [GPBDescriptor allocDescriptorForClass:[WagesHome class]
                                              rootClass:[WagesRoot class]
                                                   file:WagesRoot_FileDescriptor()
                                                 fields:fields
                                             fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                                 oneofs:NULL
                                             oneofCount:0
                                                  enums:NULL
                                              enumCount:0
                                                 ranges:NULL
                                             rangeCount:0
                                            storageSize:sizeof(WagesHome_Storage)
                                             wireFormat:NO];
  }
  return descriptor;
}

@end

#pragma mark - MyWages

@implementation MyWages

@dynamic hasUserInfo, userInfo;
@dynamic wagesItemsArray;
@dynamic hasWagesCount, wagesCount;

typedef struct MyWages_Storage {
  uint32_t _has_storage_[1];
  User *userInfo;
  NSMutableArray *wagesItemsArray;
  int64_t wagesCount;
} MyWages_Storage;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userInfo",
        .number = MyWages_FieldNumber_UserInfo,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .type = GPBTypeMessage,
        .offset = offsetof(MyWages_Storage, userInfo),
        .defaultValue.valueMessage = nil,
        .typeSpecific.className = GPBStringifySymbol(User),
        .fieldOptions = NULL,
      },
      {
        .name = "wagesItemsArray",
        .number = MyWages_FieldNumber_WagesItemsArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .type = GPBTypeMessage,
        .offset = offsetof(MyWages_Storage, wagesItemsArray),
        .defaultValue.valueMessage = nil,
        .typeSpecific.className = GPBStringifySymbol(Wages),
        .fieldOptions = NULL,
      },
      {
        .name = "wagesCount",
        .number = MyWages_FieldNumber_WagesCount,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .type = GPBTypeInt64,
        .offset = offsetof(MyWages_Storage, wagesCount),
        .defaultValue.valueInt64 = 0LL,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    descriptor = [GPBDescriptor allocDescriptorForClass:[MyWages class]
                                              rootClass:[WagesRoot class]
                                                   file:WagesRoot_FileDescriptor()
                                                 fields:fields
                                             fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                                 oneofs:NULL
                                             oneofCount:0
                                                  enums:NULL
                                              enumCount:0
                                                 ranges:NULL
                                             rangeCount:0
                                            storageSize:sizeof(MyWages_Storage)
                                             wireFormat:NO];
  }
  return descriptor;
}

@end

#pragma mark - MyFollow

@implementation MyFollow

@dynamic hasUserInfo, userInfo;
@dynamic followUsersArray;
@dynamic hasFollowUserCount, followUserCount;

typedef struct MyFollow_Storage {
  uint32_t _has_storage_[1];
  int32_t followUserCount;
  User *userInfo;
  NSMutableArray *followUsersArray;
} MyFollow_Storage;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userInfo",
        .number = MyFollow_FieldNumber_UserInfo,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .type = GPBTypeMessage,
        .offset = offsetof(MyFollow_Storage, userInfo),
        .defaultValue.valueMessage = nil,
        .typeSpecific.className = GPBStringifySymbol(User),
        .fieldOptions = NULL,
      },
      {
        .name = "followUsersArray",
        .number = MyFollow_FieldNumber_FollowUsersArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .type = GPBTypeMessage,
        .offset = offsetof(MyFollow_Storage, followUsersArray),
        .defaultValue.valueMessage = nil,
        .typeSpecific.className = GPBStringifySymbol(User),
        .fieldOptions = NULL,
      },
      {
        .name = "followUserCount",
        .number = MyFollow_FieldNumber_FollowUserCount,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .type = GPBTypeInt32,
        .offset = offsetof(MyFollow_Storage, followUserCount),
        .defaultValue.valueInt32 = 0,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    descriptor = [GPBDescriptor allocDescriptorForClass:[MyFollow class]
                                              rootClass:[WagesRoot class]
                                                   file:WagesRoot_FileDescriptor()
                                                 fields:fields
                                             fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                                 oneofs:NULL
                                             oneofCount:0
                                                  enums:NULL
                                              enumCount:0
                                                 ranges:NULL
                                             rangeCount:0
                                            storageSize:sizeof(MyFollow_Storage)
                                             wireFormat:NO];
  }
  return descriptor;
}

@end

#pragma mark - WagesDetail

@implementation WagesDetail

@dynamic hasUserInfo, userInfo;
@dynamic hasIsFocusedCreateUser, isFocusedCreateUser;
@dynamic hasWinAmount, winAmount;
@dynamic hasRecommandAttitude, recommandAttitude;
@dynamic hasRecommandReason, recommandReason;
@dynamic hasIsFree, isFree;
@dynamic hasPrice, price;
@dynamic hasSellCount, sellCount;
@dynamic hasIsBuy, isBuy;
@dynamic betItemsArray;

typedef struct WagesDetail_Storage {
  uint32_t _has_storage_[1];
  BOOL isFocusedCreateUser;
  BOOL isFree;
  BOOL isBuy;
  int32_t price;
  int32_t sellCount;
  User *userInfo;
  NSString *winAmount;
  NSString *recommandAttitude;
  NSString *recommandReason;
  NSMutableArray *betItemsArray;
} WagesDetail_Storage;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userInfo",
        .number = WagesDetail_FieldNumber_UserInfo,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .type = GPBTypeMessage,
        .offset = offsetof(WagesDetail_Storage, userInfo),
        .defaultValue.valueMessage = nil,
        .typeSpecific.className = GPBStringifySymbol(User),
        .fieldOptions = NULL,
      },
      {
        .name = "isFocusedCreateUser",
        .number = WagesDetail_FieldNumber_IsFocusedCreateUser,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .type = GPBTypeBool,
        .offset = offsetof(WagesDetail_Storage, isFocusedCreateUser),
        .defaultValue.valueBool = NO,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "winAmount",
        .number = WagesDetail_FieldNumber_WinAmount,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(WagesDetail_Storage, winAmount),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "recommandAttitude",
        .number = WagesDetail_FieldNumber_RecommandAttitude,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(WagesDetail_Storage, recommandAttitude),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "recommandReason",
        .number = WagesDetail_FieldNumber_RecommandReason,
        .hasIndex = 4,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(WagesDetail_Storage, recommandReason),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "isFree",
        .number = WagesDetail_FieldNumber_IsFree,
        .hasIndex = 5,
        .flags = GPBFieldOptional,
        .type = GPBTypeBool,
        .offset = offsetof(WagesDetail_Storage, isFree),
        .defaultValue.valueBool = NO,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "price",
        .number = WagesDetail_FieldNumber_Price,
        .hasIndex = 6,
        .flags = GPBFieldOptional,
        .type = GPBTypeInt32,
        .offset = offsetof(WagesDetail_Storage, price),
        .defaultValue.valueInt32 = 0,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "sellCount",
        .number = WagesDetail_FieldNumber_SellCount,
        .hasIndex = 7,
        .flags = GPBFieldOptional,
        .type = GPBTypeInt32,
        .offset = offsetof(WagesDetail_Storage, sellCount),
        .defaultValue.valueInt32 = 0,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "isBuy",
        .number = WagesDetail_FieldNumber_IsBuy,
        .hasIndex = 8,
        .flags = GPBFieldOptional,
        .type = GPBTypeBool,
        .offset = offsetof(WagesDetail_Storage, isBuy),
        .defaultValue.valueBool = NO,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "betItemsArray",
        .number = WagesDetail_FieldNumber_BetItemsArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .type = GPBTypeMessage,
        .offset = offsetof(WagesDetail_Storage, betItemsArray),
        .defaultValue.valueMessage = nil,
        .typeSpecific.className = GPBStringifySymbol(BetItem),
        .fieldOptions = NULL,
      },
    };
    descriptor = [GPBDescriptor allocDescriptorForClass:[WagesDetail class]
                                              rootClass:[WagesRoot class]
                                                   file:WagesRoot_FileDescriptor()
                                                 fields:fields
                                             fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                                 oneofs:NULL
                                             oneofCount:0
                                                  enums:NULL
                                              enumCount:0
                                                 ranges:NULL
                                             rangeCount:0
                                            storageSize:sizeof(WagesDetail_Storage)
                                             wireFormat:NO];
  }
  return descriptor;
}

@end

#pragma mark - ExpertWages

@implementation ExpertWages

@dynamic hasUserInfo, userInfo;
@dynamic wagesItemsArray;
@dynamic hasIsFocused, isFocused;
@dynamic hasWagesCount, wagesCount;

typedef struct ExpertWages_Storage {
  uint32_t _has_storage_[1];
  BOOL isFocused;
  User *userInfo;
  NSMutableArray *wagesItemsArray;
  int64_t wagesCount;
} ExpertWages_Storage;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userInfo",
        .number = ExpertWages_FieldNumber_UserInfo,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .type = GPBTypeMessage,
        .offset = offsetof(ExpertWages_Storage, userInfo),
        .defaultValue.valueMessage = nil,
        .typeSpecific.className = GPBStringifySymbol(User),
        .fieldOptions = NULL,
      },
      {
        .name = "wagesItemsArray",
        .number = ExpertWages_FieldNumber_WagesItemsArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .type = GPBTypeMessage,
        .offset = offsetof(ExpertWages_Storage, wagesItemsArray),
        .defaultValue.valueMessage = nil,
        .typeSpecific.className = GPBStringifySymbol(Wages),
        .fieldOptions = NULL,
      },
      {
        .name = "isFocused",
        .number = ExpertWages_FieldNumber_IsFocused,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .type = GPBTypeBool,
        .offset = offsetof(ExpertWages_Storage, isFocused),
        .defaultValue.valueBool = NO,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "wagesCount",
        .number = ExpertWages_FieldNumber_WagesCount,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .type = GPBTypeInt64,
        .offset = offsetof(ExpertWages_Storage, wagesCount),
        .defaultValue.valueInt64 = 0LL,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    descriptor = [GPBDescriptor allocDescriptorForClass:[ExpertWages class]
                                              rootClass:[WagesRoot class]
                                                   file:WagesRoot_FileDescriptor()
                                                 fields:fields
                                             fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                                 oneofs:NULL
                                             oneofCount:0
                                                  enums:NULL
                                              enumCount:0
                                                 ranges:NULL
                                             rangeCount:0
                                            storageSize:sizeof(ExpertWages_Storage)
                                             wireFormat:NO];
  }
  return descriptor;
}

@end

#pragma mark - HotMatches

@implementation HotMatches

@dynamic matchesArray;

typedef struct HotMatches_Storage {
  uint32_t _has_storage_[1];
  NSMutableArray *matchesArray;
} HotMatches_Storage;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "matchesArray",
        .number = HotMatches_FieldNumber_MatchesArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .type = GPBTypeMessage,
        .offset = offsetof(HotMatches_Storage, matchesArray),
        .defaultValue.valueMessage = nil,
        .typeSpecific.className = GPBStringifySymbol(Match),
        .fieldOptions = NULL,
      },
    };
    descriptor = [GPBDescriptor allocDescriptorForClass:[HotMatches class]
                                              rootClass:[WagesRoot class]
                                                   file:WagesRoot_FileDescriptor()
                                                 fields:fields
                                             fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                                 oneofs:NULL
                                             oneofCount:0
                                                  enums:NULL
                                              enumCount:0
                                                 ranges:NULL
                                             rangeCount:0
                                            storageSize:sizeof(HotMatches_Storage)
                                             wireFormat:NO];
  }
  return descriptor;
}

@end

#pragma mark - MatchWages

@implementation MatchWages

@dynamic hasMatch, match;
@dynamic wagesItemsArray;
@dynamic hasWagesCount, wagesCount;
@dynamic hasCommentCount, commentCount;

typedef struct MatchWages_Storage {
  uint32_t _has_storage_[1];
  int32_t wagesCount;
  int32_t commentCount;
  Match *match;
  NSMutableArray *wagesItemsArray;
} MatchWages_Storage;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "match",
        .number = MatchWages_FieldNumber_Match,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .type = GPBTypeMessage,
        .offset = offsetof(MatchWages_Storage, match),
        .defaultValue.valueMessage = nil,
        .typeSpecific.className = GPBStringifySymbol(Match),
        .fieldOptions = NULL,
      },
      {
        .name = "wagesItemsArray",
        .number = MatchWages_FieldNumber_WagesItemsArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .type = GPBTypeMessage,
        .offset = offsetof(MatchWages_Storage, wagesItemsArray),
        .defaultValue.valueMessage = nil,
        .typeSpecific.className = GPBStringifySymbol(Wages),
        .fieldOptions = NULL,
      },
      {
        .name = "wagesCount",
        .number = MatchWages_FieldNumber_WagesCount,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .type = GPBTypeInt32,
        .offset = offsetof(MatchWages_Storage, wagesCount),
        .defaultValue.valueInt32 = 0,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "commentCount",
        .number = MatchWages_FieldNumber_CommentCount,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .type = GPBTypeInt32,
        .offset = offsetof(MatchWages_Storage, commentCount),
        .defaultValue.valueInt32 = 0,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    descriptor = [GPBDescriptor allocDescriptorForClass:[MatchWages class]
                                              rootClass:[WagesRoot class]
                                                   file:WagesRoot_FileDescriptor()
                                                 fields:fields
                                             fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                                 oneofs:NULL
                                             oneofCount:0
                                                  enums:NULL
                                              enumCount:0
                                                 ranges:NULL
                                             rangeCount:0
                                            storageSize:sizeof(MatchWages_Storage)
                                             wireFormat:NO];
  }
  return descriptor;
}

@end

#pragma mark - MatchComments

@implementation MatchComments

@dynamic hasMatch, match;
@dynamic commentsArray;
@dynamic hasWagesCount, wagesCount;
@dynamic hasCommentCount, commentCount;

typedef struct MatchComments_Storage {
  uint32_t _has_storage_[1];
  int32_t wagesCount;
  int32_t commentCount;
  Match *match;
  NSMutableArray *commentsArray;
} MatchComments_Storage;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "match",
        .number = MatchComments_FieldNumber_Match,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .type = GPBTypeMessage,
        .offset = offsetof(MatchComments_Storage, match),
        .defaultValue.valueMessage = nil,
        .typeSpecific.className = GPBStringifySymbol(Match),
        .fieldOptions = NULL,
      },
      {
        .name = "commentsArray",
        .number = MatchComments_FieldNumber_CommentsArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .type = GPBTypeMessage,
        .offset = offsetof(MatchComments_Storage, commentsArray),
        .defaultValue.valueMessage = nil,
        .typeSpecific.className = GPBStringifySymbol(PBMComment),
        .fieldOptions = NULL,
      },
      {
        .name = "wagesCount",
        .number = MatchComments_FieldNumber_WagesCount,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .type = GPBTypeInt32,
        .offset = offsetof(MatchComments_Storage, wagesCount),
        .defaultValue.valueInt32 = 0,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "commentCount",
        .number = MatchComments_FieldNumber_CommentCount,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .type = GPBTypeInt32,
        .offset = offsetof(MatchComments_Storage, commentCount),
        .defaultValue.valueInt32 = 0,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    descriptor = [GPBDescriptor allocDescriptorForClass:[MatchComments class]
                                              rootClass:[WagesRoot class]
                                                   file:WagesRoot_FileDescriptor()
                                                 fields:fields
                                             fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                                 oneofs:NULL
                                             oneofCount:0
                                                  enums:NULL
                                              enumCount:0
                                                 ranges:NULL
                                             rangeCount:0
                                            storageSize:sizeof(MatchComments_Storage)
                                             wireFormat:NO];
  }
  return descriptor;
}

@end

#pragma mark - ProfitRanking

@implementation ProfitRanking

@dynamic profitItemsArray;
@dynamic leagueConfigsArray;

typedef struct ProfitRanking_Storage {
  uint32_t _has_storage_[1];
  NSMutableArray *profitItemsArray;
  NSMutableArray *leagueConfigsArray;
} ProfitRanking_Storage;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "profitItemsArray",
        .number = ProfitRanking_FieldNumber_ProfitItemsArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .type = GPBTypeMessage,
        .offset = offsetof(ProfitRanking_Storage, profitItemsArray),
        .defaultValue.valueMessage = nil,
        .typeSpecific.className = GPBStringifySymbol(ProfitRanking_profitItem),
        .fieldOptions = NULL,
      },
      {
        .name = "leagueConfigsArray",
        .number = ProfitRanking_FieldNumber_LeagueConfigsArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .type = GPBTypeMessage,
        .offset = offsetof(ProfitRanking_Storage, leagueConfigsArray),
        .defaultValue.valueMessage = nil,
        .typeSpecific.className = GPBStringifySymbol(ProfitRanking_LeagueConfig),
        .fieldOptions = NULL,
      },
    };
    descriptor = [GPBDescriptor allocDescriptorForClass:[ProfitRanking class]
                                              rootClass:[WagesRoot class]
                                                   file:WagesRoot_FileDescriptor()
                                                 fields:fields
                                             fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                                 oneofs:NULL
                                             oneofCount:0
                                                  enums:NULL
                                              enumCount:0
                                                 ranges:NULL
                                             rangeCount:0
                                            storageSize:sizeof(ProfitRanking_Storage)
                                             wireFormat:NO];
  }
  return descriptor;
}

@end

#pragma mark - ProfitRanking_profitItem

@implementation ProfitRanking_profitItem

@dynamic hasProfit, profit;
@dynamic hasUserId, userId;
@dynamic hasFansCount, fansCount;
@dynamic hasIsFocused, isFocused;
@dynamic hasUserName, userName;

typedef struct ProfitRanking_profitItem_Storage {
  uint32_t _has_storage_[1];
  BOOL isFocused;
  int32_t fansCount;
  NSString *profit;
  NSString *userName;
  int64_t userId;
} ProfitRanking_profitItem_Storage;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "profit",
        .number = ProfitRanking_profitItem_FieldNumber_Profit,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(ProfitRanking_profitItem_Storage, profit),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "userId",
        .number = ProfitRanking_profitItem_FieldNumber_UserId,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .type = GPBTypeInt64,
        .offset = offsetof(ProfitRanking_profitItem_Storage, userId),
        .defaultValue.valueInt64 = 0LL,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "fansCount",
        .number = ProfitRanking_profitItem_FieldNumber_FansCount,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .type = GPBTypeInt32,
        .offset = offsetof(ProfitRanking_profitItem_Storage, fansCount),
        .defaultValue.valueInt32 = 0,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "isFocused",
        .number = ProfitRanking_profitItem_FieldNumber_IsFocused,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .type = GPBTypeBool,
        .offset = offsetof(ProfitRanking_profitItem_Storage, isFocused),
        .defaultValue.valueBool = NO,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "userName",
        .number = ProfitRanking_profitItem_FieldNumber_UserName,
        .hasIndex = 4,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(ProfitRanking_profitItem_Storage, userName),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    descriptor = [GPBDescriptor allocDescriptorForClass:[ProfitRanking_profitItem class]
                                              rootClass:[WagesRoot class]
                                                   file:WagesRoot_FileDescriptor()
                                                 fields:fields
                                             fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                                 oneofs:NULL
                                             oneofCount:0
                                                  enums:NULL
                                              enumCount:0
                                                 ranges:NULL
                                             rangeCount:0
                                            storageSize:sizeof(ProfitRanking_profitItem_Storage)
                                             wireFormat:NO];
  }
  return descriptor;
}

@end

#pragma mark - ProfitRanking_LeagueConfig

@implementation ProfitRanking_LeagueConfig

@dynamic hasId_p, id_p;
@dynamic hasLeagueName, leagueName;

typedef struct ProfitRanking_LeagueConfig_Storage {
  uint32_t _has_storage_[1];
  int32_t id_p;
  NSString *leagueName;
} ProfitRanking_LeagueConfig_Storage;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .number = ProfitRanking_LeagueConfig_FieldNumber_Id_p,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .type = GPBTypeInt32,
        .offset = offsetof(ProfitRanking_LeagueConfig_Storage, id_p),
        .defaultValue.valueInt32 = 0,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "leagueName",
        .number = ProfitRanking_LeagueConfig_FieldNumber_LeagueName,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(ProfitRanking_LeagueConfig_Storage, leagueName),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    descriptor = [GPBDescriptor allocDescriptorForClass:[ProfitRanking_LeagueConfig class]
                                              rootClass:[WagesRoot class]
                                                   file:WagesRoot_FileDescriptor()
                                                 fields:fields
                                             fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                                 oneofs:NULL
                                             oneofCount:0
                                                  enums:NULL
                                              enumCount:0
                                                 ranges:NULL
                                             rangeCount:0
                                            storageSize:sizeof(ProfitRanking_LeagueConfig_Storage)
                                             wireFormat:NO];
  }
  return descriptor;
}

@end

#pragma mark - FansRanking

@implementation FansRanking

@dynamic fansItemsArray;

typedef struct FansRanking_Storage {
  uint32_t _has_storage_[1];
  NSMutableArray *fansItemsArray;
} FansRanking_Storage;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fansItemsArray",
        .number = FansRanking_FieldNumber_FansItemsArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .type = GPBTypeMessage,
        .offset = offsetof(FansRanking_Storage, fansItemsArray),
        .defaultValue.valueMessage = nil,
        .typeSpecific.className = GPBStringifySymbol(FansRanking_FansItem),
        .fieldOptions = NULL,
      },
    };
    descriptor = [GPBDescriptor allocDescriptorForClass:[FansRanking class]
                                              rootClass:[WagesRoot class]
                                                   file:WagesRoot_FileDescriptor()
                                                 fields:fields
                                             fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                                 oneofs:NULL
                                             oneofCount:0
                                                  enums:NULL
                                              enumCount:0
                                                 ranges:NULL
                                             rangeCount:0
                                            storageSize:sizeof(FansRanking_Storage)
                                             wireFormat:NO];
  }
  return descriptor;
}

@end

#pragma mark - FansRanking_FansItem

@implementation FansRanking_FansItem

@dynamic hasNewFans, newFans;
@dynamic hasUserId, userId;
@dynamic hasUserIcon, userIcon;
@dynamic hasIsFocused, isFocused;
@dynamic hasUserName, userName;

typedef struct FansRanking_FansItem_Storage {
  uint32_t _has_storage_[1];
  BOOL isFocused;
  int32_t newFans;
  NSString *userIcon;
  NSString *userName;
  int64_t userId;
} FansRanking_FansItem_Storage;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "newFans",
        .number = FansRanking_FansItem_FieldNumber_NewFans,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .type = GPBTypeInt32,
        .offset = offsetof(FansRanking_FansItem_Storage, newFans),
        .defaultValue.valueInt32 = 0,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "userId",
        .number = FansRanking_FansItem_FieldNumber_UserId,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .type = GPBTypeInt64,
        .offset = offsetof(FansRanking_FansItem_Storage, userId),
        .defaultValue.valueInt64 = 0LL,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "userIcon",
        .number = FansRanking_FansItem_FieldNumber_UserIcon,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(FansRanking_FansItem_Storage, userIcon),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "isFocused",
        .number = FansRanking_FansItem_FieldNumber_IsFocused,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .type = GPBTypeBool,
        .offset = offsetof(FansRanking_FansItem_Storage, isFocused),
        .defaultValue.valueBool = NO,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "userName",
        .number = FansRanking_FansItem_FieldNumber_UserName,
        .hasIndex = 4,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(FansRanking_FansItem_Storage, userName),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    descriptor = [GPBDescriptor allocDescriptorForClass:[FansRanking_FansItem class]
                                              rootClass:[WagesRoot class]
                                                   file:WagesRoot_FileDescriptor()
                                                 fields:fields
                                             fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                                 oneofs:NULL
                                             oneofCount:0
                                                  enums:NULL
                                              enumCount:0
                                                 ranges:NULL
                                             rangeCount:0
                                            storageSize:sizeof(FansRanking_FansItem_Storage)
                                             wireFormat:NO];
  }
  return descriptor;
}

@end

#pragma mark - CreateWagesInput

@implementation CreateWagesInput

@dynamic hasUserId, userId;
@dynamic hasGameMatchId, gameMatchId;
@dynamic hasPrice, price;
@dynamic hasDescription_p, description_p;
@dynamic hasDeclareType, declareType;
@dynamic hasReason, reason;
@dynamic hasGameTypeId, gameTypeId;

typedef struct CreateWagesInput_Storage {
  uint32_t _has_storage_[1];
  int32_t price;
  CreateWagesInput_DeclareTypeEnume declareType;
  int32_t gameTypeId;
  NSString *description_p;
  NSString *reason;
  int64_t userId;
  int64_t gameMatchId;
} CreateWagesInput_Storage;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .number = CreateWagesInput_FieldNumber_UserId,
        .hasIndex = 0,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .type = GPBTypeInt64,
        .offset = offsetof(CreateWagesInput_Storage, userId),
        .defaultValue.valueInt64 = 0LL,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "gameMatchId",
        .number = CreateWagesInput_FieldNumber_GameMatchId,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .type = GPBTypeInt64,
        .offset = offsetof(CreateWagesInput_Storage, gameMatchId),
        .defaultValue.valueInt64 = 0LL,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "price",
        .number = CreateWagesInput_FieldNumber_Price,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .type = GPBTypeInt32,
        .offset = offsetof(CreateWagesInput_Storage, price),
        .defaultValue.valueInt32 = 0,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "description_p",
        .number = CreateWagesInput_FieldNumber_Description_p,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(CreateWagesInput_Storage, description_p),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "declareType",
        .number = CreateWagesInput_FieldNumber_DeclareType,
        .hasIndex = 4,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .type = GPBTypeEnum,
        .offset = offsetof(CreateWagesInput_Storage, declareType),
        .defaultValue.valueEnum = CreateWagesInput_DeclareTypeEnume_Radical,
        .typeSpecific.enumDescFunc = CreateWagesInput_DeclareTypeEnume_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "reason",
        .number = CreateWagesInput_FieldNumber_Reason,
        .hasIndex = 5,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(CreateWagesInput_Storage, reason),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "gameTypeId",
        .number = CreateWagesInput_FieldNumber_GameTypeId,
        .hasIndex = 6,
        .flags = GPBFieldOptional,
        .type = GPBTypeInt32,
        .offset = offsetof(CreateWagesInput_Storage, gameTypeId),
        .defaultValue.valueInt32 = 0,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    static GPBMessageEnumDescription enums[] = {
      { .enumDescriptorFunc = CreateWagesInput_DeclareTypeEnume_EnumDescriptor },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\002\001\006\000\002\013\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    descriptor = [GPBDescriptor allocDescriptorForClass:[CreateWagesInput class]
                                              rootClass:[WagesRoot class]
                                                   file:WagesRoot_FileDescriptor()
                                                 fields:fields
                                             fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                                 oneofs:NULL
                                             oneofCount:0
                                                  enums:enums
                                              enumCount:sizeof(enums) / sizeof(GPBMessageEnumDescription)
                                                 ranges:NULL
                                             rangeCount:0
                                            storageSize:sizeof(CreateWagesInput_Storage)
                                             wireFormat:NO
                                    extraTextFormatInfo:extraTextFormatInfo];
  }
  return descriptor;
}

@end

#pragma mark - Enum CreateWagesInput_DeclareTypeEnume

GPBEnumDescriptor *CreateWagesInput_DeclareTypeEnume_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "Radical", .number = CreateWagesInput_DeclareTypeEnume_Radical },
      { .name = "Solid", .number = CreateWagesInput_DeclareTypeEnume_Solid },
    };
    static const char *extraTextFormatInfo = "\002\000\007\000\001\005\000";
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CreateWagesInput_DeclareTypeEnume)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:CreateWagesInput_DeclareTypeEnume_IsValidValue
                                      extraTextFormatInfo:extraTextFormatInfo];
  }
  return descriptor;
}

BOOL CreateWagesInput_DeclareTypeEnume_IsValidValue(int32_t value__) {
  switch (value__) {
    case CreateWagesInput_DeclareTypeEnume_Radical:
    case CreateWagesInput_DeclareTypeEnume_Solid:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - CreateWagesOuput

@implementation CreateWagesOuput

@dynamic hasWagesId, wagesId;

typedef struct CreateWagesOuput_Storage {
  uint32_t _has_storage_[1];
  int64_t wagesId;
} CreateWagesOuput_Storage;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "wagesId",
        .number = CreateWagesOuput_FieldNumber_WagesId,
        .hasIndex = 0,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .type = GPBTypeInt64,
        .offset = offsetof(CreateWagesOuput_Storage, wagesId),
        .defaultValue.valueInt64 = 0LL,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\001\007\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    descriptor = [GPBDescriptor allocDescriptorForClass:[CreateWagesOuput class]
                                              rootClass:[WagesRoot class]
                                                   file:WagesRoot_FileDescriptor()
                                                 fields:fields
                                             fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                                 oneofs:NULL
                                             oneofCount:0
                                                  enums:NULL
                                              enumCount:0
                                                 ranges:NULL
                                             rangeCount:0
                                            storageSize:sizeof(CreateWagesOuput_Storage)
                                             wireFormat:NO
                                    extraTextFormatInfo:extraTextFormatInfo];
  }
  return descriptor;
}

@end

#pragma mark - PayWagesInput

@implementation PayWagesInput

@dynamic hasWagesId, wagesId;
@dynamic hasPassword, password;

typedef struct PayWagesInput_Storage {
  uint32_t _has_storage_[1];
  NSString *password;
  int64_t wagesId;
} PayWagesInput_Storage;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "wagesId",
        .number = PayWagesInput_FieldNumber_WagesId,
        .hasIndex = 0,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .type = GPBTypeInt64,
        .offset = offsetof(PayWagesInput_Storage, wagesId),
        .defaultValue.valueInt64 = 0LL,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "password",
        .number = PayWagesInput_FieldNumber_Password,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(PayWagesInput_Storage, password),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\001\007\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    descriptor = [GPBDescriptor allocDescriptorForClass:[PayWagesInput class]
                                              rootClass:[WagesRoot class]
                                                   file:WagesRoot_FileDescriptor()
                                                 fields:fields
                                             fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                                 oneofs:NULL
                                             oneofCount:0
                                                  enums:NULL
                                              enumCount:0
                                                 ranges:NULL
                                             rangeCount:0
                                            storageSize:sizeof(PayWagesInput_Storage)
                                             wireFormat:NO
                                    extraTextFormatInfo:extraTextFormatInfo];
  }
  return descriptor;
}

@end

#pragma mark - WagesUserInfo

@implementation WagesUserInfo

@dynamic hasAmount, amount;
@dynamic hasWagesLevel, wagesLevel;
@dynamic hasWagesMaxAmount, wagesMaxAmount;
@dynamic hasIsCanCreateWages, isCanCreateWages;
@dynamic hasTodayCreateWagesCount, todayCreateWagesCount;
@dynamic hasIsOpenBetAccount, isOpenBetAccount;

typedef struct WagesUserInfo_Storage {
  uint32_t _has_storage_[1];
  BOOL isCanCreateWages;
  BOOL isOpenBetAccount;
  int32_t wagesLevel;
  int32_t wagesMaxAmount;
  int32_t todayCreateWagesCount;
  NSString *amount;
} WagesUserInfo_Storage;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "amount",
        .number = WagesUserInfo_FieldNumber_Amount,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(WagesUserInfo_Storage, amount),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "wagesLevel",
        .number = WagesUserInfo_FieldNumber_WagesLevel,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .type = GPBTypeInt32,
        .offset = offsetof(WagesUserInfo_Storage, wagesLevel),
        .defaultValue.valueInt32 = 0,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "wagesMaxAmount",
        .number = WagesUserInfo_FieldNumber_WagesMaxAmount,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .type = GPBTypeInt32,
        .offset = offsetof(WagesUserInfo_Storage, wagesMaxAmount),
        .defaultValue.valueInt32 = 0,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "isCanCreateWages",
        .number = WagesUserInfo_FieldNumber_IsCanCreateWages,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .type = GPBTypeBool,
        .offset = offsetof(WagesUserInfo_Storage, isCanCreateWages),
        .defaultValue.valueBool = NO,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "todayCreateWagesCount",
        .number = WagesUserInfo_FieldNumber_TodayCreateWagesCount,
        .hasIndex = 4,
        .flags = GPBFieldOptional,
        .type = GPBTypeInt32,
        .offset = offsetof(WagesUserInfo_Storage, todayCreateWagesCount),
        .defaultValue.valueInt32 = 0,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "isOpenBetAccount",
        .number = WagesUserInfo_FieldNumber_IsOpenBetAccount,
        .hasIndex = 5,
        .flags = GPBFieldOptional,
        .type = GPBTypeBool,
        .offset = offsetof(WagesUserInfo_Storage, isOpenBetAccount),
        .defaultValue.valueBool = NO,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    descriptor = [GPBDescriptor allocDescriptorForClass:[WagesUserInfo class]
                                              rootClass:[WagesRoot class]
                                                   file:WagesRoot_FileDescriptor()
                                                 fields:fields
                                             fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                                 oneofs:NULL
                                             oneofCount:0
                                                  enums:NULL
                                              enumCount:0
                                                 ranges:NULL
                                             rangeCount:0
                                            storageSize:sizeof(WagesUserInfo_Storage)
                                             wireFormat:NO];
  }
  return descriptor;
}

@end

#pragma mark - EditWagesUserInput

@implementation EditWagesUserInput

@dynamic hasDesription, desription;

typedef struct EditWagesUserInput_Storage {
  uint32_t _has_storage_[1];
  NSString *desription;
} EditWagesUserInput_Storage;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "desription",
        .number = EditWagesUserInput_FieldNumber_Desription,
        .hasIndex = 0,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .type = GPBTypeString,
        .offset = offsetof(EditWagesUserInput_Storage, desription),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\001J\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    descriptor = [GPBDescriptor allocDescriptorForClass:[EditWagesUserInput class]
                                              rootClass:[WagesRoot class]
                                                   file:WagesRoot_FileDescriptor()
                                                 fields:fields
                                             fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                                 oneofs:NULL
                                             oneofCount:0
                                                  enums:NULL
                                              enumCount:0
                                                 ranges:NULL
                                             rangeCount:0
                                            storageSize:sizeof(EditWagesUserInput_Storage)
                                             wireFormat:NO
                                    extraTextFormatInfo:extraTextFormatInfo];
  }
  return descriptor;
}

@end

#pragma mark - EditAttention

@implementation EditAttention

@dynamic hasUserId, userId;

typedef struct EditAttention_Storage {
  uint32_t _has_storage_[1];
  int64_t userId;
} EditAttention_Storage;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .number = EditAttention_FieldNumber_UserId,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .type = GPBTypeInt64,
        .offset = offsetof(EditAttention_Storage, userId),
        .defaultValue.valueInt64 = 0LL,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    descriptor = [GPBDescriptor allocDescriptorForClass:[EditAttention class]
                                              rootClass:[WagesRoot class]
                                                   file:WagesRoot_FileDescriptor()
                                                 fields:fields
                                             fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                                 oneofs:NULL
                                             oneofCount:0
                                                  enums:NULL
                                              enumCount:0
                                                 ranges:NULL
                                             rangeCount:0
                                            storageSize:sizeof(EditAttention_Storage)
                                             wireFormat:NO];
  }
  return descriptor;
}

@end

#pragma mark - Wages

@implementation Wages

@dynamic hasId_p, id_p;
@dynamic hasUserId, userId;
@dynamic hasUserName, userName;
@dynamic hasUserIcon, userIcon;
@dynamic hasUserLever, userLever;
@dynamic hasPrice, price;
@dynamic hasRecentWinRate, recentWinRate;
@dynamic hasIsFree, isFree;
@dynamic hasBuyCount, buyCount;
@dynamic hasIsBuy, isBuy;
@dynamic hasProfit, profit;
@dynamic betItemsArray;

typedef struct Wages_Storage {
  uint32_t _has_storage_[1];
  BOOL isFree;
  BOOL isBuy;
  int32_t userLever;
  int32_t price;
  int32_t buyCount;
  NSString *userName;
  NSString *userIcon;
  NSString *recentWinRate;
  NSString *profit;
  NSMutableArray *betItemsArray;
  int64_t id_p;
  int64_t userId;
} Wages_Storage;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .number = Wages_FieldNumber_Id_p,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .type = GPBTypeInt64,
        .offset = offsetof(Wages_Storage, id_p),
        .defaultValue.valueInt64 = 0LL,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "userId",
        .number = Wages_FieldNumber_UserId,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .type = GPBTypeInt64,
        .offset = offsetof(Wages_Storage, userId),
        .defaultValue.valueInt64 = 0LL,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "userName",
        .number = Wages_FieldNumber_UserName,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(Wages_Storage, userName),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "userIcon",
        .number = Wages_FieldNumber_UserIcon,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(Wages_Storage, userIcon),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "userLever",
        .number = Wages_FieldNumber_UserLever,
        .hasIndex = 4,
        .flags = GPBFieldOptional,
        .type = GPBTypeInt32,
        .offset = offsetof(Wages_Storage, userLever),
        .defaultValue.valueInt32 = 0,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "price",
        .number = Wages_FieldNumber_Price,
        .hasIndex = 5,
        .flags = GPBFieldOptional,
        .type = GPBTypeInt32,
        .offset = offsetof(Wages_Storage, price),
        .defaultValue.valueInt32 = 0,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "recentWinRate",
        .number = Wages_FieldNumber_RecentWinRate,
        .hasIndex = 6,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(Wages_Storage, recentWinRate),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "isFree",
        .number = Wages_FieldNumber_IsFree,
        .hasIndex = 7,
        .flags = GPBFieldOptional,
        .type = GPBTypeBool,
        .offset = offsetof(Wages_Storage, isFree),
        .defaultValue.valueBool = NO,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "buyCount",
        .number = Wages_FieldNumber_BuyCount,
        .hasIndex = 8,
        .flags = GPBFieldOptional,
        .type = GPBTypeInt32,
        .offset = offsetof(Wages_Storage, buyCount),
        .defaultValue.valueInt32 = 0,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "isBuy",
        .number = Wages_FieldNumber_IsBuy,
        .hasIndex = 9,
        .flags = GPBFieldOptional,
        .type = GPBTypeBool,
        .offset = offsetof(Wages_Storage, isBuy),
        .defaultValue.valueBool = NO,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "profit",
        .number = Wages_FieldNumber_Profit,
        .hasIndex = 10,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(Wages_Storage, profit),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "betItemsArray",
        .number = Wages_FieldNumber_BetItemsArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .type = GPBTypeMessage,
        .offset = offsetof(Wages_Storage, betItemsArray),
        .defaultValue.valueMessage = nil,
        .typeSpecific.className = GPBStringifySymbol(BetItem),
        .fieldOptions = NULL,
      },
    };
    descriptor = [GPBDescriptor allocDescriptorForClass:[Wages class]
                                              rootClass:[WagesRoot class]
                                                   file:WagesRoot_FileDescriptor()
                                                 fields:fields
                                             fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                                 oneofs:NULL
                                             oneofCount:0
                                                  enums:NULL
                                              enumCount:0
                                                 ranges:NULL
                                             rangeCount:0
                                            storageSize:sizeof(Wages_Storage)
                                             wireFormat:NO];
  }
  return descriptor;
}

@end

#pragma mark - User

@implementation User

@dynamic hasUserName, userName;
@dynamic hasUserLever, userLever;
@dynamic hasUserIcon, userIcon;
@dynamic hasFansCount, fansCount;
@dynamic hasWinRate, winRate;
@dynamic hasRecentWeekWinRate, recentWeekWinRate;
@dynamic hasRecentMonthProfit, recentMonthProfit;
@dynamic hasRencentWeekProfit, rencentWeekProfit;
@dynamic hasUserTag, userTag;
@dynamic hasUserDescrption, userDescrption;
@dynamic hasUserId, userId;

typedef struct User_Storage {
  uint32_t _has_storage_[1];
  int32_t userLever;
  NSString *userName;
  NSString *userIcon;
  NSString *winRate;
  NSString *recentWeekWinRate;
  NSString *recentMonthProfit;
  NSString *rencentWeekProfit;
  NSString *userTag;
  NSString *userDescrption;
  int64_t fansCount;
  int64_t userId;
} User_Storage;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userName",
        .number = User_FieldNumber_UserName,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(User_Storage, userName),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "userLever",
        .number = User_FieldNumber_UserLever,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .type = GPBTypeInt32,
        .offset = offsetof(User_Storage, userLever),
        .defaultValue.valueInt32 = 0,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "userIcon",
        .number = User_FieldNumber_UserIcon,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(User_Storage, userIcon),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "fansCount",
        .number = User_FieldNumber_FansCount,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .type = GPBTypeInt64,
        .offset = offsetof(User_Storage, fansCount),
        .defaultValue.valueInt64 = 0LL,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "winRate",
        .number = User_FieldNumber_WinRate,
        .hasIndex = 4,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(User_Storage, winRate),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "recentWeekWinRate",
        .number = User_FieldNumber_RecentWeekWinRate,
        .hasIndex = 5,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(User_Storage, recentWeekWinRate),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "recentMonthProfit",
        .number = User_FieldNumber_RecentMonthProfit,
        .hasIndex = 6,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(User_Storage, recentMonthProfit),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "rencentWeekProfit",
        .number = User_FieldNumber_RencentWeekProfit,
        .hasIndex = 7,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(User_Storage, rencentWeekProfit),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "userTag",
        .number = User_FieldNumber_UserTag,
        .hasIndex = 8,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(User_Storage, userTag),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "userDescrption",
        .number = User_FieldNumber_UserDescrption,
        .hasIndex = 9,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(User_Storage, userDescrption),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "userId",
        .number = User_FieldNumber_UserId,
        .hasIndex = 10,
        .flags = GPBFieldOptional,
        .type = GPBTypeInt64,
        .offset = offsetof(User_Storage, userId),
        .defaultValue.valueInt64 = 0LL,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    descriptor = [GPBDescriptor allocDescriptorForClass:[User class]
                                              rootClass:[WagesRoot class]
                                                   file:WagesRoot_FileDescriptor()
                                                 fields:fields
                                             fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                                 oneofs:NULL
                                             oneofCount:0
                                                  enums:NULL
                                              enumCount:0
                                                 ranges:NULL
                                             rangeCount:0
                                            storageSize:sizeof(User_Storage)
                                             wireFormat:NO];
  }
  return descriptor;
}

@end

#pragma mark - BetItem

@implementation BetItem

@dynamic hasOrderNumberName, orderNumberName;
@dynamic hasStartDate, startDate;
@dynamic hasHomeTeamName, homeTeamName;
@dynamic hasAwayTemaName, awayTemaName;
@dynamic hasOption, option;
@dynamic hasIsWin, isWin;
@dynamic hasSp, sp;
@dynamic hasResult, result;
@dynamic hasEndDate, endDate;

typedef struct BetItem_Storage {
  uint32_t _has_storage_[1];
  BOOL isWin;
  NSString *orderNumberName;
  NSString *startDate;
  NSString *homeTeamName;
  NSString *awayTemaName;
  NSString *option;
  NSString *sp;
  NSString *result;
  NSString *endDate;
} BetItem_Storage;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "orderNumberName",
        .number = BetItem_FieldNumber_OrderNumberName,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(BetItem_Storage, orderNumberName),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "startDate",
        .number = BetItem_FieldNumber_StartDate,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(BetItem_Storage, startDate),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "homeTeamName",
        .number = BetItem_FieldNumber_HomeTeamName,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(BetItem_Storage, homeTeamName),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "awayTemaName",
        .number = BetItem_FieldNumber_AwayTemaName,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(BetItem_Storage, awayTemaName),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "option",
        .number = BetItem_FieldNumber_Option,
        .hasIndex = 4,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(BetItem_Storage, option),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "isWin",
        .number = BetItem_FieldNumber_IsWin,
        .hasIndex = 5,
        .flags = GPBFieldOptional,
        .type = GPBTypeBool,
        .offset = offsetof(BetItem_Storage, isWin),
        .defaultValue.valueBool = NO,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "sp",
        .number = BetItem_FieldNumber_Sp,
        .hasIndex = 6,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(BetItem_Storage, sp),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "result",
        .number = BetItem_FieldNumber_Result,
        .hasIndex = 7,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(BetItem_Storage, result),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "endDate",
        .number = BetItem_FieldNumber_EndDate,
        .hasIndex = 8,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(BetItem_Storage, endDate),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    descriptor = [GPBDescriptor allocDescriptorForClass:[BetItem class]
                                              rootClass:[WagesRoot class]
                                                   file:WagesRoot_FileDescriptor()
                                                 fields:fields
                                             fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                                 oneofs:NULL
                                             oneofCount:0
                                                  enums:NULL
                                              enumCount:0
                                                 ranges:NULL
                                             rangeCount:0
                                            storageSize:sizeof(BetItem_Storage)
                                             wireFormat:NO];
  }
  return descriptor;
}

@end

#pragma mark - Match

@implementation Match

@dynamic hasCompetitionName, competitionName;
@dynamic hasHomeTeamName, homeTeamName;
@dynamic hasAwayTemaName, awayTemaName;
@dynamic hasEndDate, endDate;
@dynamic hasWagesCount, wagesCount;
@dynamic hasHomeTeamIcon, homeTeamIcon;
@dynamic hasAwayTemaIcon, awayTemaIcon;
@dynamic hasGameTypeId, gameTypeId;
@dynamic hasMatchId, matchId;

typedef struct Match_Storage {
  uint32_t _has_storage_[1];
  int32_t wagesCount;
  int32_t gameTypeId;
  NSString *competitionName;
  NSString *homeTeamName;
  NSString *awayTemaName;
  NSString *endDate;
  NSString *homeTeamIcon;
  NSString *awayTemaIcon;
  int64_t matchId;
} Match_Storage;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "competitionName",
        .number = Match_FieldNumber_CompetitionName,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(Match_Storage, competitionName),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "homeTeamName",
        .number = Match_FieldNumber_HomeTeamName,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(Match_Storage, homeTeamName),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "awayTemaName",
        .number = Match_FieldNumber_AwayTemaName,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(Match_Storage, awayTemaName),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "endDate",
        .number = Match_FieldNumber_EndDate,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(Match_Storage, endDate),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "wagesCount",
        .number = Match_FieldNumber_WagesCount,
        .hasIndex = 4,
        .flags = GPBFieldOptional,
        .type = GPBTypeInt32,
        .offset = offsetof(Match_Storage, wagesCount),
        .defaultValue.valueInt32 = 0,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "homeTeamIcon",
        .number = Match_FieldNumber_HomeTeamIcon,
        .hasIndex = 5,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(Match_Storage, homeTeamIcon),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "awayTemaIcon",
        .number = Match_FieldNumber_AwayTemaIcon,
        .hasIndex = 6,
        .flags = GPBFieldOptional,
        .type = GPBTypeString,
        .offset = offsetof(Match_Storage, awayTemaIcon),
        .defaultValue.valueString = nil,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "gameTypeId",
        .number = Match_FieldNumber_GameTypeId,
        .hasIndex = 7,
        .flags = GPBFieldOptional,
        .type = GPBTypeInt32,
        .offset = offsetof(Match_Storage, gameTypeId),
        .defaultValue.valueInt32 = 0,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "matchId",
        .number = Match_FieldNumber_MatchId,
        .hasIndex = 8,
        .flags = GPBFieldOptional,
        .type = GPBTypeInt64,
        .offset = offsetof(Match_Storage, matchId),
        .defaultValue.valueInt64 = 0LL,
        .typeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    descriptor = [GPBDescriptor allocDescriptorForClass:[Match class]
                                              rootClass:[WagesRoot class]
                                                   file:WagesRoot_FileDescriptor()
                                                 fields:fields
                                             fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                                 oneofs:NULL
                                             oneofCount:0
                                                  enums:NULL
                                              enumCount:0
                                                 ranges:NULL
                                             rangeCount:0
                                            storageSize:sizeof(Match_Storage)
                                             wireFormat:NO];
  }
  return descriptor;
}

@end


// @@protoc_insertion_point(global_scope)
